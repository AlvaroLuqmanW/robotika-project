using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;

#if UNITY_EDITOR
using UnityEditor;
#endif

/// <summary>
/// Handles pathfinding between multiple targets, finding the most efficient route using BruteForce algorithm.
/// 
/// UPDATED BEHAVIOR:
/// - The robot finds the shortest path to visit all area markers using BruteForce optimization.
/// - When a marker is reached, the robot will explore the area's grid points to find the bomb.
/// - During exploration, the robot uses SphereCast to detect bombs in multiple directions.
/// - When a bomb is found, the robot navigates to it, defuses it, and then proceeds to the next area.
/// - This process repeats until all areas have been visited and their bombs found.
/// 
/// REQUIREMENTS:
/// - Area markers must have an AreaGridGenerator component.
/// - Bombs must be tagged as "Bomb" and have a Bomb component.
/// - Each area should have grid points generated by the AreaGridGenerator.
/// </summary>
public class MultiTargetPathfinder : MonoBehaviour
{
    [Header("References")]
    public RobotController robotController;
    public RobotPathfinding pathfinding;
    
    [Header("Target Settings")]
    [Tooltip("List of targets to visit")]
    public List<Transform> targets = new List<Transform>();
    
    [Tooltip("Should the robot return to starting position?")]
    public bool returnToStart = false;
    
    [Header("Area Exploration")]
    [Tooltip("Enable bomb search in each area")]
    public bool searchForBombs = true;
    
    [Tooltip("Radius to detect bombs with SphereCast")]
    public float bombDetectionRadius = 1.0f;
    
    [Tooltip("Maximum distance for bomb detection")]
    public float bombDetectionDistance = 5.0f;
    
    [Tooltip("Layers to include in bomb detection")]
    public LayerMask bombDetectionLayers = -1;
    
    [Tooltip("Time between grid point movements during exploration")]
    public float explorationMoveDelay = 0.5f;
    
    [Header("Debugging")]
    [Tooltip("Show debug lines for optimized path")]
    public bool showOptimizedPath = true;
    
    [Tooltip("Show debug rays for bomb detection")]
    public bool showBombDetection = true;
    
    [Header("Status")]
    [SerializeField] private int currentTargetIndex = -1;
    [SerializeField] private bool routeComplete = false;
    [SerializeField] public bool isExploringArea = false;
    
    // Optimization method (locked to BruteForce)
    [HideInInspector] public RouteOptimizationMethod optimizationMethod = RouteOptimizationMethod.BruteForce;
    
    // Optimized route of target indices
    private List<int> optimizedRoute = new List<int>();
    
    // Starting position
    private Vector3 startPosition;
    
    // Current area being explored
    private AreaGridGenerator currentArea;
    
    // List of grid points to visit in the current area
    private List<Vector3> areaGridPoints = new List<Vector3>();
    
    // Index of current grid point being visited
    private int currentGridPointIndex = 0;
    
    // Are we currently processing?
    private bool isProcessing = false;
    
    public enum RouteOptimizationMethod
    {
        NearestNeighbor,       // Simple greedy algorithm, fast but suboptimal
        BruteForce,            // Optimal for small numbers of targets (max ~10)
        NearestInsertion       // Better than nearest neighbor, not optimal but reasonable
    }
    
    private void Start()
    {
        if (robotController == null)
            robotController = GetComponent<RobotController>();
            
        if (pathfinding == null && robotController != null)
            pathfinding = robotController.pathfinding;
            
        if (pathfinding == null)
            pathfinding = GetComponent<RobotPathfinding>();
            
        // Store starting position
        startPosition = transform.position;
        
        // Check for errors
        if (pathfinding == null)
        {
            Debug.LogError("No RobotPathfinding component found!");
            enabled = false;
            return;
        }
        
        // Force BruteForce algorithm
        optimizationMethod = RouteOptimizationMethod.BruteForce;
        
        // Register for target reached event
        StartCoroutine(CheckTargetReachedRoutine());
    }
    
    /// <summary>
    /// Starts navigation to all targets in the optimized order
    /// </summary>
    public void StartMultiTargetNavigation()
    {
        if (targets.Count == 0)
        {
            Debug.LogWarning("No targets set for multi-target navigation!");
            return;
        }
        
        if (isProcessing)
        {
            Debug.LogWarning("Already processing a route!");
            return;
        }
        
        if (targets.Count > 10)
        {
            Debug.LogWarning("BruteForce algorithm works best with 10 or fewer targets. Performance may be affected.");
        }
        
        isProcessing = true;
        routeComplete = false;
        currentTargetIndex = -1;
        
        // Optimize the route
        OptimizeRoute();
        
        // Start navigation to first target
        MoveToNextTarget();
    }
    
    /// <summary>
    /// Stops the current multi-target navigation
    /// </summary>
    public void StopNavigation()
    {
        isProcessing = false;
        pathfinding.target = null;
    }
    
    /// <summary>
    /// Optimize the route using the brute force method
    /// </summary>
    public void OptimizeRoute()
    {
        if (targets.Count == 0)
            return;
            
        optimizedRoute.Clear();
        OptimizeBruteForce();
        
        // Log the optimized route
        Debug.Log("Calculated optimal route using BruteForce algorithm: " + string.Join(" â†’ ", optimizedRoute));
    }
    
    /// <summary>
    /// Move to the next target in the optimized route
    /// </summary>
    private void MoveToNextTarget()
    {
        if (!isProcessing || optimizedRoute.Count == 0)
            return;
            
        currentTargetIndex++;
        
        // Check if we've completed all targets
        if (currentTargetIndex >= optimizedRoute.Count)
        {
            // Check if we should return to start
            if (returnToStart)
            {
                Debug.Log("All targets visited, returning to start position");
                
                // Create a temporary target at the start position
                GameObject tempTarget = new GameObject("TempStartTarget");
                tempTarget.transform.position = startPosition;
                
                // Set as target
                pathfinding.target = tempTarget.transform;
                
                // Destroy after 0.1 seconds (after pathfinding has started)
                Destroy(tempTarget, 0.1f);
                
                // Mark as complete once we reach the start
                StartCoroutine(CheckReturnToStartRoutine());
            }
            else
            {
                // Route is complete
                routeComplete = true;
                isProcessing = false;
                Debug.Log("Multi-target route complete!");
            }
            
            return;
        }
        
        // Move to the next target
        int targetIndex = optimizedRoute[currentTargetIndex];
        pathfinding.target = targets[targetIndex];
        
        Debug.Log("Moving to target " + (currentTargetIndex + 1) + "/" + optimizedRoute.Count + " (index: " + targetIndex + ")");
    }
    
    /// <summary>
    /// Check if we've reached the current target
    /// </summary>
    private IEnumerator CheckTargetReachedRoutine()
    {
        float checkInterval = 0.2f;
        
        while (true)
        {
            // Skip if we're not processing or no target
            if (!isProcessing || pathfinding.target == null)
            {
                yield return new WaitForSeconds(checkInterval);
                continue;
            }
            
            // Check if target reached by looking at pathfinding
            float distance = Vector3.Distance(transform.position, pathfinding.target.position);
            
            if (distance <= pathfinding.arrivalDistance)
            {
                // Wait a bit to make sure we've really stopped
                yield return new WaitForSeconds(0.5f);
                
                // Target reached
                Debug.Log("Target reached!");
                
                // If we're not already exploring and this is a marker target (not a grid point)
                if (searchForBombs && !isExploringArea && pathfinding.target.gameObject.GetComponent<AreaGridGenerator>() != null)
                {
                    // Start exploring the area
                    StartCoroutine(ExploreAreaForBomb(pathfinding.target.gameObject.GetComponent<AreaGridGenerator>()));
                }
                else if (!isExploringArea)
                {
                    // Move to next target if we're not exploring an area
                    MoveToNextTarget();
                }
            }
            
            yield return new WaitForSeconds(checkInterval);
        }
    }
    
    /// <summary>
    /// Explore an area to find a bomb
    /// </summary>
    private IEnumerator ExploreAreaForBomb(AreaGridGenerator areaGrid)
    {
        Debug.Log("Starting area exploration to find bomb...");
        
        isExploringArea = true;
        currentArea = areaGrid;
        
        // Get grid points from the area
        areaGridPoints = areaGrid.GetGridPoints();
        
        if (areaGridPoints.Count == 0)
        {
            Debug.LogWarning("No grid points found in area! Skipping exploration.");
            isExploringArea = false;
            MoveToNextTarget();
            yield break;
        }
        
        Debug.Log("Found " + areaGridPoints.Count + " grid points to explore.");
        
        // First, check if there's a bomb near our current position before exploring
        if (ScanForBomb())
        {
            // Bomb found immediately, finish exploration
            isExploringArea = false;
            yield return new WaitForSeconds(1.0f); // Give time for the robot to reach and defuse the bomb
            MoveToNextTarget();
            yield break;
        }
        
        // Find the center point of the area (average of all grid points)
        Vector3 centerPoint = Vector3.zero;
        foreach (Vector3 point in areaGridPoints)
        {
            centerPoint += point;
        }
        centerPoint /= areaGridPoints.Count;
        
        // Sort grid points by distance from the center (for spiral pattern)
        areaGridPoints.Sort((a, b) => {
            float distA = Vector3.Distance(a, centerPoint);
            float distB = Vector3.Distance(b, centerPoint);
            return distA.CompareTo(distB);
        });
        
        // Create a spiral pattern by alternating between expanding and shrinking distances
        List<Vector3> spiralPoints = CreateSpiralPattern(areaGridPoints, centerPoint);
        
        // Initialize for exploration
        bool bombFound = false;
        int pointsVisited = 0;
        float explorationStartTime = Time.time;
        
        // Now explore in a spiral pattern
        foreach (Vector3 nextPoint in spiralPoints)
        {
            // Move to the next grid point
            GameObject tempTarget = new GameObject("TempGridPointTarget");
            tempTarget.transform.position = nextPoint;
            pathfinding.target = tempTarget.transform;
            
            // Wait until we reach the grid point or timeout
            float timeoutDuration = 5.0f; // shorter timeout for efficiency
            float elapsedTime = 0f;
            bool reachedPoint = false;
            
            while (!reachedPoint && elapsedTime < timeoutDuration)
            {
                float distance = Vector3.Distance(transform.position, nextPoint);
                if (distance <= pathfinding.arrivalDistance)
                {
                    reachedPoint = true;
                }
                
                // Check for bombs during movement - not just at grid points
                if (ScanForBomb())
                {
                    bombFound = true;
                    Destroy(tempTarget);
                    break;
                }
                
                elapsedTime += 0.1f;
                yield return new WaitForSeconds(0.1f);
            }
            
            // Clean up the temporary target
            Destroy(tempTarget);
            
            // Count visited points and give status updates
            pointsVisited++;
            if (pointsVisited % 5 == 0)
            {
                Debug.Log($"Explored {pointsVisited}/{spiralPoints.Count} grid points so far");
            }
            
            // Check if we found the bomb during movement
            if (bombFound)
            {
                Debug.Log("Found bomb while navigating grid!");
                break;
            }
            
            // Scan for bomb at this location
            if (ScanForBomb())
            {
                bombFound = true;
                Debug.Log("Found bomb at grid point!");
                break;
            }
            
            // Check if we're taking too long - speed up the search if so
            float timeSpentExploring = Time.time - explorationStartTime;
            if (timeSpentExploring > 30f) // If more than 30 seconds spent
            {
                // Skip some points to speed up exploration
                int skipCount = Mathf.Min(3, spiralPoints.Count - pointsVisited - 1);
                for (int i = 0; i < skipCount; i++)
                {
                    pointsVisited++;
                    if (pointsVisited >= spiralPoints.Count)
                        break;
                }
            }
            
            // Small delay between movements - shorter for efficiency
            yield return new WaitForSeconds(explorationMoveDelay * 0.5f);
        }
        
        if (!bombFound)
        {
            Debug.LogWarning("Explored entire area but failed to find bomb!");
            
            // Last resort - do a thorough scan of the entire area
            bombFound = PerformThoroughAreaScan();
        }
        
        // Finished exploring area
        isExploringArea = false;
        
        // Move to the next marker after finishing exploration
        MoveToNextTarget();
    }
    
    /// <summary>
    /// Creates a spiral pattern of points for more efficient exploration
    /// </summary>
    private List<Vector3> CreateSpiralPattern(List<Vector3> points, Vector3 center)
    {
        List<Vector3> result = new List<Vector3>();
        
        // First, add a few points near the robot's current position for initial search
        Vector3 currentPos = transform.position;
        
        // Create a copy of the points list
        List<Vector3> workingPoints = new List<Vector3>(points);
        
        // Add closest 5 points to robot first
        workingPoints.Sort((a, b) => 
            Vector3.Distance(a, currentPos).CompareTo(Vector3.Distance(b, currentPos)));
        
        // Add the 5 closest points first (or fewer if there aren't that many)
        int closestCount = Mathf.Min(5, workingPoints.Count);
        for (int i = 0; i < closestCount; i++)
        {
            result.Add(workingPoints[i]);
        }
        
        // Remove these points from the working list
        workingPoints.RemoveRange(0, closestCount);
        
        // Remaining points will be sorted in spiral pattern around center
        List<Vector3> spiralPoints = new List<Vector3>(workingPoints);
        
        // Sort by angle, cycling through 8 sectors around the center
        // This creates a spiral pattern when combined with the distance sorting
        spiralPoints.Sort((a, b) => {
            // Calculate angle from center
            float angleA = Mathf.Atan2(a.z - center.z, a.x - center.x);
            float angleB = Mathf.Atan2(b.z - center.z, b.x - center.x);
            
            // Get sector (0-7) for the point based on angle
            int sectorA = Mathf.FloorToInt((angleA + Mathf.PI) * 4 / Mathf.PI) % 8;
            int sectorB = Mathf.FloorToInt((angleB + Mathf.PI) * 4 / Mathf.PI) % 8;
            
            // Compare sectors first
            if (sectorA != sectorB)
                return sectorA.CompareTo(sectorB);
            
            // If in same sector, compare distance from center
            float distA = Vector3.Distance(a, center);
            float distB = Vector3.Distance(b, center);
            return distA.CompareTo(distB);
        });
        
        // Add these spiral-sorted points to the result
        result.AddRange(spiralPoints);
        
        return result;
    }
    
    /// <summary>
    /// Last resort method to perform a thorough scan of the area
    /// </summary>
    private bool PerformThoroughAreaScan()
    {
        Debug.Log("Performing thorough area scan as last resort...");
        
        // Get the area bounds from the current area
        if (currentArea == null || currentArea.GetGridPoints().Count == 0)
            return false;
        
        // Calculate the area bounds
        Vector3 min = Vector3.positiveInfinity;
        Vector3 max = Vector3.negativeInfinity;
        
        foreach (Vector3 point in currentArea.GetGridPoints())
        {
            min = Vector3.Min(min, point);
            max = Vector3.Max(max, point);
        }
        
        // Increase bomb detection parameters temporarily for a more thorough scan
        float originalRadius = bombDetectionRadius;
        float originalDistance = bombDetectionDistance;
        
        bombDetectionRadius *= 1.5f;
        bombDetectionDistance *= 1.5f;
        
        // Perform a detailed grid scan of the area
        bool bombFound = false;
        for (float x = min.x; x <= max.x; x += bombDetectionRadius * 0.5f)
        {
            for (float z = min.z; z <= max.z; z += bombDetectionRadius * 0.5f)
            {
                // Create a point in the middle of the area
                Vector3 scanPoint = new Vector3(x, transform.position.y, z);
                
                // Check if this point is within NavMesh
                NavMeshHit hit;
                if (NavMesh.SamplePosition(scanPoint, out hit, bombDetectionRadius, NavMesh.AllAreas))
                {
                    // Draw debug spheres in the editor
                    if (showBombDetection)
                    {
                        Debug.DrawLine(transform.position, hit.position, Color.blue, 0.5f);
                    }
                    
                    // Perform a detailed scan at this position
                    if (ScanForBomb())
                    {
                        bombFound = true;
                        break;
                    }
                }
            }
            
            if (bombFound)
                break;
        }
        
        // Restore original parameters
        bombDetectionRadius = originalRadius;
        bombDetectionDistance = originalDistance;
        
        return bombFound;
    }
    
    /// <summary>
    /// Scan for bomb using SphereCast from the current position
    /// </summary>
    private bool ScanForBomb()
    {
        // Try multiple directions for better coverage
        Vector3[] directions = new Vector3[]
        {
            Vector3.forward,
            Vector3.back,
            Vector3.left,
            Vector3.right,
            (Vector3.forward + Vector3.right).normalized,
            (Vector3.forward + Vector3.left).normalized,
            (Vector3.back + Vector3.right).normalized,
            (Vector3.back + Vector3.left).normalized
        };
        
        foreach (Vector3 direction in directions)
        {
            RaycastHit hit;
            Vector3 rayStart = transform.position + Vector3.up * 0.5f; // Start a bit above the ground
            
            // Debug ray visualization
            if (showBombDetection)
            {
                Debug.DrawRay(rayStart, direction * bombDetectionDistance, Color.red, 0.5f);
            }
            
            if (Physics.SphereCast(rayStart, bombDetectionRadius, direction, out hit, bombDetectionDistance, bombDetectionLayers))
            {
                // Check if we hit a bomb
                if (hit.collider.CompareTag("Bombs"))
                {
                    Debug.Log("Detected bomb! Moving to defuse it...");
                    
                    // Track the current bomb we're targeting
                    GameObject bombTarget = hit.collider.gameObject;
                    
                    // Create a temporary target at the bomb location
                    GameObject tempTarget = new GameObject("TempBombTarget");
                    tempTarget.transform.position = hit.collider.transform.position;
                    
                    // Set as target
                    pathfinding.target = tempTarget.transform;
                    
                    // Start a coroutine to wait until we reach the bomb
                    StartCoroutine(WaitForBombReach(bombTarget, tempTarget));
                    
                    // Don't destroy tempTarget here, it will be destroyed in the coroutine
                    return true;
                }
            }
        }
        
        return false;
    }
    
    /// <summary>
    /// Waits until the robot reaches the bomb target
    /// </summary>
    private IEnumerator WaitForBombReach(GameObject bombTarget, GameObject tempTarget)
    {
        // Disable additional bomb detection while we're heading to a bomb
        bool wasExploring = isExploringArea;
        isExploringArea = false;
        
        // Wait until we get close enough to the bomb or timeout
        float timeoutDuration = 15.0f;  // Longer timeout to ensure the robot has time to navigate
        float elapsedTime = 0f;
        
        Debug.Log("Moving to defuse bomb...");
        
        // Keep tracking until we reach the bomb, it's defused, or we timeout
        while (elapsedTime < timeoutDuration)
        {
            // Check if the bomb is still active (hasn't been defused)
            if (bombTarget == null || !bombTarget.activeInHierarchy)
            {
                Debug.Log("Bomb has been defused successfully");
                break;
            }
            
            // Just wait and let the robot's collision with the bomb trigger the defuse naturally
            elapsedTime += 0.1f;
            yield return new WaitForSeconds(0.1f);
        }
        
        // Clean up the temporary target
        if (tempTarget != null)
        {
            Destroy(tempTarget);
        }
        
        // If we timed out, log a warning
        if (elapsedTime >= timeoutDuration)
        {
            Debug.LogWarning("Timed out while trying to reach bomb");
        }
        
        // Wait a bit to make sure defuse process completes if it happened
        yield return new WaitForSeconds(1.0f);
        
        // If we were exploring before, and the exploration isn't over yet, resume exploring
        if (wasExploring && currentArea != null)
        {
            isExploringArea = true;
        }
    }
    
    /// <summary>
    /// Check if we've returned to the start position
    /// </summary>
    private IEnumerator CheckReturnToStartRoutine()
    {
        float checkInterval = 0.2f;
        
        while (true)
        {
            // Skip if we're not processing
            if (!isProcessing)
            {
                yield break;
            }
            
            // Check if we're back at start
            float distance = Vector3.Distance(transform.position, startPosition);
            
            if (distance <= pathfinding.arrivalDistance)
            {
                // Route is complete
                routeComplete = true;
                isProcessing = false;
                Debug.Log("Multi-target route complete! Returned to start position.");
                yield break;
            }
            
            yield return new WaitForSeconds(checkInterval);
        }
    }
    
    /// <summary>
    /// Optimize using brute force (exact optimal solution)
    /// </summary>
    private void OptimizeBruteForce()
    {
        List<int> indices = new List<int>();
        for (int i = 0; i < targets.Count; i++)
            indices.Add(i);
            
        List<int> bestRoute = new List<int>();
        float shortestDistance = float.MaxValue;
        
        // Generate all permutations and find the shortest one
        BruteForcePermutations(indices, 0, ref bestRoute, ref shortestDistance);
        
        optimizedRoute = new List<int>(bestRoute);
        
        Debug.Log("Optimal path found with total distance: " + shortestDistance.ToString("F2") + " units");
    }
    
    /// <summary>
    /// Recursive helper for brute force method to generate permutations
    /// </summary>
    private void BruteForcePermutations(List<int> indices, int k, ref List<int> bestRoute, ref float shortestDistance)
    {
        if (k == indices.Count)
        {
            // Calculate the total distance of this route
            float totalDistance = CalculateRouteLength(indices);
            
            if (totalDistance < shortestDistance)
            {
                shortestDistance = totalDistance;
                bestRoute = new List<int>(indices);
            }
        }
        else
        {
            for (int i = k; i < indices.Count; i++)
            {
                // Swap
                int temp = indices[k];
                indices[k] = indices[i];
                indices[i] = temp;
                
                // Recurse
                BruteForcePermutations(indices, k + 1, ref bestRoute, ref shortestDistance);
                
                // Swap back
                temp = indices[k];
                indices[k] = indices[i];
                indices[i] = temp;
            }
        }
    }
    
    /// <summary>
    /// Calculate the total length of a route
    /// </summary>
    private float CalculateRouteLength(List<int> route)
    {
        if (route.Count < 2)
            return 0;
            
        float totalDistance = 0;
        
        // Add distance from start to first target
        Vector3 startPoint = transform.position;
        Vector3 nextPoint = targets[route[0]].position;
        
        NavMeshPath path = new NavMeshPath();
        if (NavMesh.CalculatePath(startPoint, nextPoint, NavMesh.AllAreas, path))
        {
            totalDistance += CalculatePathLength(path);
        }
        else
        {
            totalDistance += Vector3.Distance(startPoint, nextPoint);
        }
        
        // Add distances between consecutive targets
        for (int i = 0; i < route.Count - 1; i++)
        {
            Vector3 fromPoint = targets[route[i]].position;
            Vector3 toPoint = targets[route[i + 1]].position;
            
            if (NavMesh.CalculatePath(fromPoint, toPoint, NavMesh.AllAreas, path))
            {
                totalDistance += CalculatePathLength(path);
            }
            else
            {
                totalDistance += Vector3.Distance(fromPoint, toPoint);
            }
        }
        
        // Add distance from last target to start if returning to start
        if (returnToStart)
        {
            Vector3 lastPoint = targets[route[route.Count - 1]].position;
            
            if (NavMesh.CalculatePath(lastPoint, startPoint, NavMesh.AllAreas, path))
            {
                totalDistance += CalculatePathLength(path);
            }
            else
            {
                totalDistance += Vector3.Distance(lastPoint, startPoint);
            }
        }
        
        return totalDistance;
    }
    
    /// <summary>
    /// Calculate the length of a NavMesh path
    /// </summary>
    private float CalculatePathLength(NavMeshPath path)
    {
        float length = 0;
        
        if (path.corners.Length < 2)
            return 0;
            
        for (int i = 0; i < path.corners.Length - 1; i++)
        {
            length += Vector3.Distance(path.corners[i], path.corners[i + 1]);
        }
        
        return length;
    }
    
    private void OnDrawGizmos()
    {
        if (!showOptimizedPath || optimizedRoute.Count == 0 || targets.Count == 0)
            return;
        
        // Draw optimized route
        Gizmos.color = Color.yellow;
        
        // Draw line from start to first target
        if (optimizedRoute.Count > 0)
        {
            Vector3 start = Application.isPlaying ? startPosition : transform.position;
            Gizmos.DrawLine(start, targets[optimizedRoute[0]].position);
        }
        
        // Draw lines between targets
        for (int i = 0; i < optimizedRoute.Count - 1; i++)
        {
            Gizmos.DrawLine(targets[optimizedRoute[i]].position, targets[optimizedRoute[i + 1]].position);
        }
        
        // Draw line from last target back to start if returning
        if (returnToStart && optimizedRoute.Count > 0)
        {
            Vector3 start = Application.isPlaying ? startPosition : transform.position;
            Gizmos.DrawLine(targets[optimizedRoute[optimizedRoute.Count - 1]].position, start);
        }
        
        // Draw spheres at each target position
        for (int i = 0; i < targets.Count; i++)
        {
            // Current target is red, others are green
            int routeIndex = optimizedRoute.IndexOf(i);
            if (routeIndex == currentTargetIndex && Application.isPlaying)
            {
                Gizmos.color = Color.red;
                Gizmos.DrawSphere(targets[i].position, 0.3f);
            }
            else
            {
                Gizmos.color = Color.green;
                Gizmos.DrawSphere(targets[i].position, 0.2f);
                
                // Editor-only code for drawing labels
                #if UNITY_EDITOR
                Handles.Label(targets[i].position + Vector3.up * 0.3f, 
                    (routeIndex != -1) ? (routeIndex + 1).ToString() : "?");
                #endif
            }
        }
    }
    
    void Update()
    {
        // Continuously scan for bombs while exploring
        if (isExploringArea)
        {
            ScanForBomb();
        }
    }
    
    public void RegenerateCurrentAreaGrid()
    {
        if (currentArea != null)
        {
            currentArea.RegenerateGrid();
            areaGridPoints = currentArea.GetGridPoints();
        }
    }
} 